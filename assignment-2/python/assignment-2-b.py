#!/usr/bin/env python3
"""========================================================================
Purpose:
    Solve a 1-D state heat transfer problem using a tri-diagonal solver to
    resolve the laplacian. 

Author:
    Emilio Torres
========================================================================"""
#=========================================================================#
# Preamble                                                                # 
#=========================================================================#
#-------------------------------------------------------------------------#
# Python packages                                                         # 
#-------------------------------------------------------------------------#
import os
import sys
from subprocess import call
from numpy import *
import scipy.linalg as la
import matplotlib.pyplot as plt
import time
#-------------------------------------------------------------------------#
# User packages                                                           # 
#-------------------------------------------------------------------------#
from ales_post.plot_settings import plot_setting
#=========================================================================#
# User defined functions                                                  # 
#=========================================================================#
#-------------------------------------------------------------------------#
# Pretty print matrix                                                     #
#-------------------------------------------------------------------------#
def print_matrix(
        mat,                  # input matrix
        var_str):

    """ Pretty printing a matrix """
    #---------------------------------------------------------------------#
    # Looping over columns and rows                                       #
    #---------------------------------------------------------------------#
    if mat.shape[1] is not False:
        out = ''                # initialize string
        for I in range(0, mat.shape[0]):
            for J in range(0, mat.shape[1]):
                out += '%12.5f'          %(mat[I,J])
            out += '\n'
    if mat.shape[1] is False:
        for I in range(0, mat.shape[0]):
            out += '%12.5f'          %(mat[I])
            out += '\n'
    print(var_str)
    print(out)
#-------------------------------------------------------------------------#
# Tri-diagonal                                                            # 
#-------------------------------------------------------------------------#
def tri_solver(
        A,
        B,
        C,
        D):

    """ Solving A tri-diagonal system """

    #---------------------------------------------------------------------#
    # Preallocating variables                                             # 
    #---------------------------------------------------------------------#
    N   = len(D)            # number of equations
    Ain = copy(A)
    Bin = copy(B) 
    Cin = copy(C) 
    Din = copy(D)
    sol = zeros(N)
    #---------------------------------------------------------------------#
    # Looping over the domain                                             # 
    #---------------------------------------------------------------------#
    for I in range(1, N):
        mult    = Ain[I-1]/Bin[I-1]
        Bin[I]  = Bin[I] - mult*Cin[I-1] 
        Din[I]  = Din[I] - mult*Din[I-1]
    #---------------------------------------------------------------------#
    # Preallocation solutions                                             # 
    #---------------------------------------------------------------------#
    sol[-1]     = Din[-1]/Bin[-1]
    #---------------------------------------------------------------------#
    # Interior solutions                                                  # 
    #---------------------------------------------------------------------#
    for I in range(N-2, -1, -1):
        sol[I] = (Din[I]-Cin[I]*sol[I+1])/Bin[I]

    return sol
#=========================================================================#
# Main                                                                    # 
#=========================================================================#
if __name__ == '__main__':
    #---------------------------------------------------------------------#
    # Main preamble                                                       #
    #---------------------------------------------------------------------#
    call(['clear'])
    sep         = os.sep
    pwd         = os.getcwd()
    media_path  = pwd + '%c..%cmedia%c'                 %(sep, sep, sep)
    #---------------------------------------------------------------------#
    # Exact solution                                                      #
    #---------------------------------------------------------------------#
    xc      = linspace(0.0, 1.0, 1000)
    #---------------------------------------------------------------------#
    # Plotting settings and variables                                     #
    #---------------------------------------------------------------------#
    plot_setting()
    sym = ['r', 'g', 'b', 'c', 'm']
    #---------------------------------------------------------------------#
    # Domain variables                                                    #
    #---------------------------------------------------------------------#
    num     = [4,8,16,32,64]
    time1   = zeros(len(num))
    time2   = zeros(len(num))
    error   = zeros(len(num))
    dx      = zeros(len(num))
    #---------------------------------------------------------------------#
    # Looping over the grid sizes                                         #
    #---------------------------------------------------------------------#
    for n in range(0, len(num)):
        #-----------------------------------------------------------------#
        # Step size variables                                             #
        #-----------------------------------------------------------------#
        print(num[n])
        M       = num[n]
        L       = 1.0
        dx[n]   = L/float(M)
        alpha   = 1.0
        x       = linspace(0.0, 1.0, M+1)
        #-----------------------------------------------------------------#
        # Generating 4D vectors                                           #
        #-----------------------------------------------------------------#
        T       = zeros(len(x))
        a       = ones(len(x)-3)
        b       = -2.0*ones(len(x)-2)
        c       = ones(len(x)-3)
        d       = -50.*sin(2.*pi*x[1:M])
        d       = dx[n]**2.0*d
        d[-1]   = d[-1]-50
        d[0]    = d[0]-10
        #-----------------------------------------------------------------#
        # Approximate solution                                            #
        #-----------------------------------------------------------------#
        T[1:M]  = tri_solver(a,b,c,d)
        T[0]    = 10.
        T[-1]   = 50.
        #-----------------------------------------------------------------#
        # Exact solution                                                  #
        #-----------------------------------------------------------------#
        Te      = 50.0/(4.0*pi**2.0)*sin(2.*pi*x) + 40.*x + 10.
        #-----------------------------------------------------------------#
        # Calculating the error                                           #
        #-----------------------------------------------------------------#
        error[n]    = amax(abs(Te-T))
        #-----------------------------------------------------------------#
        # Plotting the solution                                           # 
        #-----------------------------------------------------------------#
        plt.plot(x,T, sym[n], lw=1.5, label='$N=%i$'    %(M))
    #---------------------------------------------------------------------#
    # Plot settings                                                       # 
    #---------------------------------------------------------------------#
    plt.plot(x, Te, 'b--', lw=3.0, label='Analytical')
    plt.grid(True)
    plt.xlabel('$0 \leq x \leq 1$')
    plt.ylabel('Temperature [non-dimensional]')
    plt.legend(loc=0)
    plt.savefig(media_path + 'temperature-profile.png')
    plt.close()
    #---------------------------------------------------------------------#
    # Plotting the error                                                  # 
    #---------------------------------------------------------------------#
    plt.loglog(dx, error, 'r', lw=1.5, label='Approximation error') 
    plt.loglog(dx, 1.75*dx**2.0 , 'k', lw=1.5, label="$\sim c_{1} x^{2}$")
    plt.grid(True, which='both', ls='-')
    plt.legend(loc=0)
    plt.xlabel('$\Delta x $')
    plt.ylabel('Error')
    plt.savefig(media_path + 'error-profile.png')
    plt.close()

    print('**** Successful Run ****')
    sys.exit(0)
